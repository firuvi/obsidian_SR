
### Объясни строку кода.

``` Java

`BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));`
```

Создаётся объект `BufferedReader`, который используется для эффективного чтения текстовых данных из потока ввода. Давай разберем эту строку по частям, чтобы понять каждый компонент:

1. **System.in**

`System.in` является стандартным потоком ввода в Java, который по умолчанию связан с клавиатурой. Он представляет собой объект `InputStream`, который может читать байты ввода.

1. **InputStreamReader**
`new InputStreamReader(System.in)` оборачивает `System.in` в объект `InputStreamReader`. `InputStreamReader` — это мост между потоками байтов (`InputStream`) и потоками символов (`Reader`). Он читает байты из `InputStream` и преобразует их в символы (char) с учетом указанной или дефолтной кодировки. Если не указать кодировку, используется кодировка платформы.

2. **BufferedReader**
`new BufferedReader(...)` создаёт объект `BufferedReader`, который оборачивает `InputStreamReader`. `BufferedReader` улучшает производительность чтения данных, добавляя возможность буферизации вводимых данных. Это значит, что каждый вызов метода чтения (например, `read()` или `readLine()`) будет обрабатывать данные из буфера, что значительно уменьшает количество обращений к физическому устройству ввода (клавиатуре, диску и т.д.). Кроме того, `BufferedReader` предоставляет удобный метод `readLine()`, который позволяет читать данные построчно.

4. **reader**
`BufferedReader reader = ...` создаёт переменную `reader` типа `BufferedReader`. Эта переменная используется для доступа к методам объекта `BufferedReader`, таким как `readLine()`, что позволяет читать строки текста из консоли.

### Тип данных и декоратор #decorator

```Java
 
 BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
```

Зачем в этом отрывке кода на Java мы пишем два раза BufferedReader?

1. **Упоминание `BufferedReader`** - это объявление типа переменной `reader`. Здесь `BufferedReader` указывает на то, что переменная `reader` будет иметь тип `BufferedReader`. Это определяет тип данных переменной, которую мы собираемся использовать для хранения ссылки на объект `BufferedReader` и оно говорит Java, что `reader` должен быть использован для хранения объекта типа `BufferedReader`. Это необходимо для того, чтобы компилятор Java знал, какие методы и свойства доступны для `reader`.
2. **Упоминание `BufferedReader`** - это вызов конструктора для создания нового объекта `BufferedReader`. Этот конструктор принимает объект `FileReader` в качестве параметра, который в свою очередь открывает файл с именем, указанным в переменной `inputFileName`.  `new BufferedReader(...)` фактически создаётся новый объект типа `BufferedReader`, который оборачивает объект `FileReader`. Это оборачивание позволяет добавить дополнительную функциональность, такую как буферизация, которая делает чтение из файла более эффективным.

**Вывод** в первом случае BufferedReader - тип переменой #ссылочный_тип_данных, во втором BufferedReader -- это класс, который наследует классу Reader.
### Чтение текста из файла

``` Java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class FileReaderExample {

	public static void main(String[] args) {
		String inputFileName = "file.txt";

		try (BufferedReader reader = new BufferedReader(new FileReader(inputFileName))) {
			String line;
			while ((line = reader.readLine()) != null) {
				System.out.println(line + "\n");
			}
		}
                catch (IOException e) {
			e.printStackTrace();
			reader.close();
		}
	}

}
```

Этот код на Java читает текст из файла и выводит его содержимое на экран. Давай разберем пошагово, что делает каждая часть кода:

- `BufferedReader` используется для буферизированного чтения текста из символьных потоков.
- `FileReader` — это удобство для чтения символов из файла.
- `IOException` — класс исключений, который обрабатывает ошибки ввода/вывода.

**Класс и метод**

`public class FileReaderExample {     public static void main(String[] args) {`

- Определен класс `FileReaderExample`.
- В классе определен метод `main`, точка входа в программу, когда она запускается.

**Определение имени файла**

`String inputFileName = "file.txt";`

Создается строковая переменная `inputFileName`, которая содержит путь к файлу, который будет читаться.

**Создание** `BufferedReader`

`try (BufferedReader reader = new BufferedReader(new FileReader(inputFileName))) {`

- Здесь используется конструкция `try-with-resources`, которая автоматически закрывает ресурсы (`BufferedReader` и `FileReader`), когда выполнение блока `try` завершено.
- `new FileReader(inputFileName)` создает новый `FileReader` для чтения из файла `file.txt`.
- `new BufferedReader(...)` оборачивает `FileReader` для буферизированного чтения.

**Чтение файла**

``` Java

String line; while ((line = reader.readLine()) != null) { System.out.println(line + "\n"); }
```


- Переменная `line` используется для хранения каждой строки, считанной из файла.
- Цикл #cycle `while` продолжается до тех пор, пока `readLine()` не вернет `null`, что означает достижение конца файла.
- В теле цикла каждая прочитанная строка выводится на экран, и добавляется перенос строки `\n` для разделения строк файла.

**Обработка исключений**

`catch (IOException e) {     e.printStackTrace(); }`

- Блок `catch` перехватывает и обрабатывает исключения типа `IOException`, которые могут возникнуть при чтении файла.
- `e.printStackTrace();` выводит трассировку стека исключения, что может помочь в диагностике проблемы при чтении файла.

**Закрытие потока**

Важно закрыть `BufferedReader` после его использования, чтобы освободить системные ресурсы, связанные с потоком. Это можно сделать вызовом метода `close()` на объекте `reader`. Если потоки не закрыть, это может привести к утечкам памяти и другим проблемам с ресурсами.

**Заключение**

Этот код показывает простой пример того, как можно читать текстовый файл в Java и выводить его содержимое на экран. Код использует обработку исключений для безопасного управления ошибками и `try-with-resources` для автоматического управления ресурсами. Это базовый пример работы с файлами и может быть расширен для более сложных задач обработки данных.

[[Streams]]